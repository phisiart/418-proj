---
title: "Projects"
bg: orange
color: black
fa-icon: toggle-on
---

## [C Compiler from scratch](https://github.com/phisiart/C-Compiler)

I've built **a complete C compiler from scratch**! It is written in C#, and it supports **all** features in C89, except for bit-fields in structs and the obsolete function declaration syntax.

I **didn't** use any automatic lexer / parser generator ([lex](https://en.wikipedia.org/wiki/Lex_(software)), [yacc](https://en.wikipedia.org/wiki/Yacc), [antlr](https://en.wikipedia.org/wiki/ANTLR)...). Instead, I coded the lexer and parser from the ground up all by my self. Having experienced all the verboseness of the handwritten recursive descent parser, I re-wrote it with [parser combinatorss](https://en.wikipedia.org/wiki/Parser_combinator) - yay, functional programming is the best!
<!--
When building and using parser combinators, I found that the most interesting thing is the recursiveness of the C syntax. It won't be too much of a trouble when you just create a function (or method) for each non-terminal. However, when you need to have them as objects (at least function objects), you will have to find a way to get around.-->

I performed semantic analysis - figuring out the type of each expression, analysing the symbol declarations, recognizing semantic errors... all these kinds of stuff.

<!--In this phase, I found some features a little tricky to implement. For example, 1) a struct might contain a pointer which points to a struct of the same type. This is very common in, lets say, linked lists.

```
struct node_t {
    int value;
    struct node_t *next;
};
```-->
<!--
Or, 2) the initialization list. You need to figure out what each element refer to.

```
struct node_t[3][4] = { node0, { 1, NULL }, { 1 } };
```-->

Finally, I generated code into x86 assembly, which can be directly used by gcc's assembler and linker. In this way, I'm able to compare the output with gcc's.

<center><img src="img/c-compiler.png" width="350"></center>

-------------------------


## Setup as standalone project page

- Go click **fork** on the [github project page](https://github.com/t413/SinglePaged)
- Rename your new repository to `whatever you want`. (click settings in the right column)
  * It will go live at yourusername.github.io/**WhateverYouWant**
- Clone your repository, cd into the project
- Run `git checkout publish && git branch -D gh-pages && git branch -m gh-pages && git push -uf origin gh-pages` to swap the *publish* and *gh-pages* branch.

Now hop over to [Usage](#usage) to get it running with your own stuff!

**When you publish changes use `git push -u origin gh-pages`**

-------------------------


## Setup inside existing project

This is the most complicated use-case .. but it's the coolest.
Say you've got your kickass project `github.com/t413/kicker` and want to have
some web presence to post about on [hacker news](http://news.ycombinator.com).
This will create an orphan branch called `gh_pages` in your repository
where you can publish changes, posts, images, and such. It won't alter your code at all.

- `cd` into your project on the command line
- use `git remote add -t publish singlepage git@github.com:t413/SinglePaged.git` to get access to this repository.
- use `git fetch singlepage publish:gh-pages` to fetch the remote branch
- use `git branch --set-upstream gh-pages singlepage/publish && git checkout gh-pages;`
  This creates and checks out an orphan branch called gh-pages that tracks the original and lets you make changes.
- When you run `git push gh-pages:origin/gh-pages` it'll be live at *yourusername.github.io/repositoryName*

Now hop over to [Usage](#usage) to get it running with your own stuff!

**When you publish changes use `git push -u origin gh-pages`**

